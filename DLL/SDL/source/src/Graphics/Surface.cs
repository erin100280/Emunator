#region LICENSE
/*
 * Copyright (C) 2004 - 2007 David Hudson (jendave@yahoo.com)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#endregion LICENSE

using System;
using System.IO;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Globalization;
using System.Reflection;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;

using Tao.Sdl;
using SdlDotNet.Core;
using SdlDotNet.Graphics.Sprites;

namespace SdlDotNet.Graphics
{
    #region Alphas

    /// <summary>
    /// Alpha flags for Video
    /// </summary>
    /// <remarks></remarks>
    [FlagsAttribute]
    internal enum Alphas
    {
        /// <summary>
        /// Equivalent to SDL_RLEACCEL
        /// </summary>
        RleEncoded = Sdl.SDL_RLEACCEL,

        /// <summary>
        /// Equivalent to SDL_SRCALPHA
        /// </summary>
        SourceAlphaBlending = Sdl.SDL_SRCALPHA
    }

    #endregion

    /// <summary>
    /// Represents an Sdl drawing surface.
    /// You can create instances of this class with the methods in the Video 
    /// object.
    /// </summary>
    public class Surface : BaseSdlResource, ICloneable
    {
        #region Private Fields
        private byte alpha;
        private bool alphaBlending;
        private bool disposed;
        private Color transparentColor;
        private bool isVideoMode;
        bool transparentInitialized;
        bool transparent;
        static bool isInitialized = Initialize();

        static Surface resizeSurface;
        static byte[] resizeBuffer;
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static bool Initialize()
        {
            Video.Initialize();
            Assembly assembly = Assembly.GetCallingAssembly();
            Stream stream = assembly.GetManifestResourceStream("SdlDotNet.Graphics.Transparent.png");
            resizeBuffer = ReadFully(stream, stream.Length);
            resizeSurface = new Surface(resizeBuffer);

            return true;
        }

        // Bmp files have a header of 54 bytes. 
        // This is used to turn the Surface into a byte array to 
        // load into a Bitmap object
        private readonly int BmpHeader = 54;
        #endregion Private Fields

        #region Constructors and Destructors

        /// <summary>
        /// Use this in conjuntion with Tao.Sdl
        /// </summary>
        /// <param name="handle"></param>
        public Surface(IntPtr handle)
        {
            this.Handle = handle;
        }

        /// <summary>
        /// If the Surface is the screen generated by SetVideoMode, 
        /// we should not call Sdl.SDL_FreeSurface() on it. 
        /// Sdl.SDL_QUIT() automatically frees it.
        /// </summary>
        /// <param name="handle"></param>
        /// <param name="isVideoMode"></param>
        internal Surface(IntPtr handle, bool isVideoMode)
        {
            this.Handle = handle;
            this.isVideoMode = isVideoMode;
        }

        /// <summary>
        /// <para>Represents a Image that can be drawn on a Sdl.Surface.</para>
        /// <para>The image can be loaded from from a file, 
        /// a System.Drawing.Bitmap, or a byte array.</para>
        /// <para>Supported image formats follows the development 
        /// cycle of SDL_Image. Currently, supported and planned 
        /// supported image formats are:</para>
        /// 
        /// <para>
        /// <list type="bullet">
        ///		<item><term>.BMP</term>
        ///		<description>Windows Bitmap</description>
        ///		</item>
        ///		<item><term>.PNM</term>
        ///		<description>Portable Anymap File Format</description>
        ///		</item>
        ///		<item><term>.XPM</term>
        ///		<description>X PixMap</description></item>
        ///		<item><term>.LBM</term>
        ///		<description>Tagged Image File Format</description>
        ///		</item>
        ///		<item><term>.PCX</term>
        ///		<description>Z-Soft’s PC Paintbrush file format</description>
        ///		</item>
        ///		<item><term>.GIF</term>
        ///		<description>Graphics Interchange Format</description>
        ///		</item>
        ///		<item><term>.JPG</term>
        ///		<description>Joint Photographic Experts Group (JPEG)
        ///		</description>
        ///		</item>
        ///		<item><term>.TIF</term>
        ///		<description>Tagged Image File Format</description>
        ///		</item>
        ///		<item><term>.PNG</term>
        ///		<description>Portable Network Graphics</description>
        ///		</item>
        ///		<item><term>.TGA</term>
        ///		<description>Truevision (Targa) File Format</description>
        ///		</item>
        ///	</list>
        ///	</para>
        /// 
        /// <para>Usage:</para>
        /// <code>
        /// Surface image = Surface("mybitmap.jpg")
        /// image.Blit(screen, new Rectangle(new Point(0,0),image.Size))
        /// </code>
        /// </summary> 
        public Surface(string file)
        {
            this.Handle = SdlImage.IMG_Load(file);
            if (this.Handle == IntPtr.Zero)
            {
                throw SdlException.Generate();
            }
        }

        /// <summary>
        /// Creates a surface with the designated size.
        /// </summary>
        /// <param name="size"></param>
        public Surface(Size size)
            : this(size.Width, size.Height)
        {
        }

        /// <summary>
        /// Creates a surface with the designated rectangle size.
        /// </summary>
        /// <param name="rectangle">Rectangle size of surface</param>
        public Surface(Rectangle rectangle)
            : this(rectangle.Width, rectangle.Height)
        {
        }

        /// <summary>
        /// Create surface of a given width and height
        /// </summary>
        /// <param name="width">Width of surface</param>
        /// <param name="height">Height of surface</param>
        public Surface(int width, int height)
            : this(width, height, VideoInfo.BitsPerPixel)
        {
        }

        /// <summary>
        /// Create surface of a given width and height
        /// </summary>
        /// <param name="width">Width of surface</param>
        /// <param name="height">Height of surface</param>
        /// <param name="bitsPerPixel">Bits per pixel</param>
        public Surface(int width, int height, int bitsPerPixel)
            : this(width, height, bitsPerPixel, VideoInfo.RedMask, VideoInfo.GreenMask, VideoInfo.BlueMask, VideoInfo.AlphaMask)
        {
        }

        /// <summary>
        /// Create surface of a given width and height
        /// </summary>
        /// <param name="width">Width of surface</param>
        /// <param name="height">Height of surface</param>
        /// <param name="bitsPerPixel">Bits per pixel</param>
        /// <param name="alphaMask">Alpha Mask</param>
        /// <param name="blueMask">Blue Mask</param>
        /// <param name="greenMask">Green Mask</param>
        /// <param name="redMask">Red Mask</param>
        public Surface(int width, int height, int bitsPerPixel, int redMask, int greenMask, int blueMask, int alphaMask)
        {
            this.Handle =
                Sdl.SDL_CreateRGBSurface((int)VideoModes.None, width, height, bitsPerPixel, redMask, greenMask, blueMask, alphaMask);
            if (this.Handle == IntPtr.Zero)
            {
                throw SdlException.Generate();
            }
        }

        /// <summary>
        /// Create surface of a given width and height.
        /// </summary>
        /// <param name="width">Width of surface</param>
        /// <param name="height">Height of surface</param>
        /// <param name="bitsPerPixel">Bits per pixel</param>
        /// <param name="alphaChannel">alphaChannel</param>
        public Surface(int width, int height, int bitsPerPixel, bool alphaChannel)
            : this(width, height, bitsPerPixel, VideoInfo.RedMask, VideoInfo.GreenMask, VideoInfo.BlueMask, alphaChannel ? VideoInfo.AlphaMask : 0)
        {
        }

        /// <summary>
        /// Create a Surface from a MemoryStream.
        /// </summary>
        /// <param name="stream"></param>
        public Surface(MemoryStream stream)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }
            byte[] array = stream.ToArray();
            this.Handle =
                SdlImage.IMG_Load_RW(Sdl.SDL_RWFromMem(array, array.Length), 1);
            if (this.Handle == IntPtr.Zero)
            {
                throw SdlException.Generate();
            }
        }

        /// <summary>
        /// Create a Surface from a byte array in memory.
        /// </summary>
        /// <param name="array">
        /// A array of bytes that contains the image data
        /// </param>
        public Surface(byte[] array)
        {
            if (array == null)
            {
                throw new ArgumentNullException("array");
            }
            this.Handle =
                SdlImage.IMG_Load_RW(Sdl.SDL_RWFromMem(array, array.Length), 1);
            if (this.Handle == IntPtr.Zero)
            {
                throw SdlException.Generate();
            }
        }

        /// <summary>
        /// Create a SdlImage instance from a System.Drawing.Bitmap object. 
        /// Loads a bitmap from a System.Drawing.Bitmap object, 
        /// usually obtained from a resource.
        /// </summary>
        /// <param name="bitmap">A System.Drawing.Bitmap object</param>
        public Surface(System.Drawing.Bitmap bitmap)
        {
            if (bitmap == null)
            {
                throw new ArgumentNullException("bitmap");
            }
            MemoryStream stream = new MemoryStream();
            bitmap.Save(stream, System.Drawing.Imaging.ImageFormat.Bmp);
            byte[] arr = stream.ToArray();
            this.Handle =
                SdlImage.IMG_Load_RW(Sdl.SDL_RWFromMem(arr, arr.Length), 1);
            if (this.Handle == IntPtr.Zero)
            {
                throw SdlException.Generate();
            }
        }

        /// <summary>
        /// Surface copy constructor.
        /// </summary>
        /// <remarks>Creates a copy of the surface at a different memory location.</remarks>
        /// <param name="surface">The surface to copy.</param>
        public Surface(Surface surface)
        {
            if (surface == null)
            {
                throw new ArgumentNullException("surface");
            }
            this.Handle = SdlGfx.zoomSurface(surface.Handle, 1, 1, SdlGfx.SMOOTHING_OFF);
            if (this.Handle == IntPtr.Zero)
            {
                throw SdlException.Generate();
            }
            CloneFields(surface, this);
        }

        #endregion Constructors and Destructors

        #region Private Methods

        /// <summary>
        /// 
        /// </summary>
        /// <param name="rect"></param>
        /// <returns></returns>
        public static Sdl.SDL_Rect ConvertRectToSdlRect(
            System.Drawing.Rectangle rect)
        {
            return new Sdl.SDL_Rect(
                (short)rect.X,
                (short)rect.Y,
                (short)rect.Width,
                (short)rect.Height);
        }

        static void CloneFields(Surface source, Surface destination)
        {
            destination.transparentColor = source.transparentColor;
            destination.transparentInitialized = source.transparentInitialized;
            destination.transparent = source.transparent;
            destination.alpha = source.alpha;
            destination.alphaBlending = source.alphaBlending;
            destination.isVideoMode = source.isVideoMode;
        }

        #endregion Private Methods

        #region Internal Methods

        internal static Surface FromScreenPtr(IntPtr surfacePtr)
        {
            return new Surface(surfacePtr);
        }

        internal Sdl.SDL_Surface SurfaceStruct
        {
            get
            {
                if (this.disposed)
                {
                    throw (new ObjectDisposedException(this.ToString()));
                }
                GC.KeepAlive(this);
                return (Sdl.SDL_Surface)Marshal.PtrToStructure(this.Handle,
                    typeof(Sdl.SDL_Surface));
            }
        }

        private Sdl.SDL_PixelFormat? pixelFormat;
        //TODO: Cache this so getpixel/setpixel is faster
        internal Sdl.SDL_PixelFormat? PixelFormat
        {
            get
            {
                if (this.disposed)
                {
                    throw (new ObjectDisposedException(this.ToString()));
                }
                GC.KeepAlive(this);
                if (!pixelFormat.HasValue)
                {
                    pixelFormat = (Sdl.SDL_PixelFormat)Marshal.PtrToStructure(this.SurfaceStruct.format,
                    typeof(Sdl.SDL_PixelFormat));
                }
                return pixelFormat;
            }
        }

        #endregion Internal Methods

        #region Protected Methods

        /// <summary>
        /// Destroys the surface object and frees its memory
        /// </summary>
        /// <param name="disposing">If true, dispose unmanaged objects</param>
        protected override void Dispose(bool disposing)
        {
            try
            {
                if (!this.disposed)
                {
                    if (disposing)
                    {
                    }
                    this.disposed = true;
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        /// <summary>
        /// Closes Surface handle
        /// </summary>
        protected override void CloseHandle()
        {
            try
            {
                if (this.Handle != IntPtr.Zero && !this.isVideoMode)
                {
                    Sdl.SDL_FreeSurface(this.Handle);
                    this.Handle = IntPtr.Zero;
                }
            }
            catch (NullReferenceException e)
            {
                e.ToString();
            }
            catch (AccessViolationException e)
            {
                Console.WriteLine(e.StackTrace);
                e.ToString();
            }
            finally
            {
                this.Handle = IntPtr.Zero;
            }
        }

        #endregion Protected Methods

        #region Public Methods
        /// <summary>
        /// 
        /// </summary>
        public static bool IsInitialized
        {
            get { return Surface.isInitialized; }
        }

        /// <summary>
        /// Creates a Bitmap representing the Surface.
        /// </summary>
        public Bitmap Bitmap
        {
            get
            {
                byte[] arr = new byte[(this.Width * this.Height * this.BytesPerPixel) + this.BmpHeader];
                IntPtr i = Marshal.AllocHGlobal(arr.Length);

                try
                {

                    try
                    {
                        Marshal.Copy(arr, 0, i, arr.Length);
                        Sdl.SDL_SaveBMP_RW(this.Handle, Sdl.SDL_RWFromMem(i, arr.Length), 1);
                        Marshal.Copy(i, arr, 0, arr.Length);
                    }
                    catch (AccessViolationException e)
                    {
                        Console.WriteLine(e.StackTrace);
                        e.ToString();
                    }

                    Bitmap bitmap;
                    try
                    {
                        if (arr != null)
                        {
                            bitmap = (Bitmap)Bitmap.FromStream(new MemoryStream(arr, 0, arr.Length));
                            return bitmap;
                        }
                        else
                        {
                            return new Bitmap(1, 1);
                        }
                    }
                    catch (OutOfMemoryException e)
                    {
                        e.ToString();
                        bitmap = new Bitmap(1, 1);
                        return bitmap;
                    }
                    catch (ArgumentException e)
                    {
                        e.ToString();
                        bitmap = new Bitmap(1, 1);
                        return bitmap;
                    }
                    catch (ExternalException e)
                    {
                        e.ToString();
                        bitmap = new Bitmap(1, 1);
                        return bitmap;
                    }
                }
                finally
                {
                    Marshal.FreeHGlobal(i);
                }
            }
        }

        /// <summary>
        /// Inverts all the colors on the surface, giving it a negative effect.
        /// </summary>
        /// <returns>The surface.</returns>
        public Surface InvertColors()
        {
            for (int x = 0; x < this.Width; x++)
            {
                for (int y = 0; y < this.Height; y++)
                {
                    this.Draw(new Point(x, y), SdlColor.Invert(this.GetPixel(new Point(x, y))));
                }
            }
            return this;
        }

        /// <summary>
        /// Replaces the given color with a different color on the whole surface.
        /// </summary>
        /// <param name="original">The original color to be replaced.</param>
        /// <param name="replacement">The new color to replace the original color.</param>
        /// <returns>The surface.</returns>
        public Surface ReplaceColor(Color original, Color replacement)
        {
            int colVal = this.GetColorValue(replacement);
            int origValue = original.ToArgb();
            for (int x = 0; x < this.Width; x++)
            {
                for (int y = 0; y < this.Height; y++)
                {
                    if (this.GetPixel(new Point(x, y)).ToArgb() == origValue)
                    {
                        this.Draw(new Point(x, y), colVal);
                    }
                }
            }
            return this;
        }

        /// <summary>
        /// Draws a rectangle onto the surface
        /// </summary>
        /// <param name="rectangle">The rectangle coordinates</param>
        /// <param name="color">The color to draw</param>
        public Rectangle Fill(System.Drawing.Rectangle rectangle,
            System.Drawing.Color color)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }

            Sdl.SDL_Rect sdlrect = ConvertRectToSdlRect(rectangle);

            int result = Sdl.SDL_FillRect(this.Handle, ref sdlrect, GetColorValue(color));
            GC.KeepAlive(this);
            if (result != (int)SdlFlag.Success)
            {
                throw SdlException.Generate();
            }
            return new Rectangle(sdlrect.x, sdlrect.y, sdlrect.w, sdlrect.h);
        }

        /// <summary>
        /// Fill entire surface with color
        /// </summary>
        /// <param name="color">Color to fill surface</param>
        public Rectangle Fill(System.Drawing.Color color)
        {
            return this.Fill(new System.Drawing.Rectangle(0, 0, this.SurfaceStruct.w, this.SurfaceStruct.h), color);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="primitive"></param>
        /// <param name="color"></param>
        public void Draw(IPrimitive primitive, Color color)
        {
            Draw(primitive, color, true);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="primitive"></param>
        /// <param name="color"></param>
        /// <param name="antiAlias"></param>
        public void Draw(IPrimitive primitive, Color color, bool antiAlias)
        {
            Draw(primitive, color, antiAlias, false);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="primitive"></param>
        /// <param name="color"></param>
        /// <param name="antiAlias"></param>
        /// <param name="fill"></param>
        public void Draw(IPrimitive primitive, Color color, bool antiAlias, bool fill)
        {
            if (primitive == null)
            {
                throw new ArgumentNullException("primitive");
            }
            primitive.Draw(this, color, antiAlias, fill);
        }

        /// <summary>
        /// Maps a logical color to a pixel value in the surface's pixel format
        /// </summary>
        /// <param name="color">The color to map</param>
        /// <returns>A pixel value in the surface's format</returns>
        public int GetColorValue(System.Drawing.Color color)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            if (this.SurfaceStruct.format != IntPtr.Zero)
            {
                GC.KeepAlive(this);
                return Sdl.SDL_MapRGBA(
                    this.SurfaceStruct.format,
                    color.R,
                    color.G,
                    color.B,
                    color.A);
            }
            else
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
        }

        /// <summary>
        /// Maps an Sdl 32-bit pixel value to a color using the surface's 
        /// pixel format
        /// </summary>
        /// <param name="colorValue">The pixel value to map</param>
        /// <returns>
        /// A Color value for a pixel value in the surface's format
        /// </returns>
        public System.Drawing.Color GetColor(int colorValue)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }

            byte r, g, b, a;
            Sdl.SDL_GetRGBA(colorValue, this.SurfaceStruct.format, out r, out g, out b, out a);
            GC.KeepAlive(this);
            return System.Drawing.Color.FromArgb(a, r, g, b);
        }

        /// <summary>
        /// Creates new surface that is the same size and compatible with this one.
        /// </summary>
        /// <returns>new Surface</returns>
        public Surface CreateCompatibleSurface()
        {
            return this.CreateCompatibleSurface(this.Size.Width, this.Size.Height, false);
        }

        /// <summary>
        /// Creates new surface that is compatible with this one.
        /// </summary>
        /// <param name="rectangle">Size of surface</param>
        /// <returns>new Surface</returns>
        public Surface CreateCompatibleSurface(Rectangle rectangle)
        {
            return this.CreateCompatibleSurface(rectangle.Width, rectangle.Height, false);
        }

        /// <summary>
        /// Creates new surface that is compatible with this one.
        /// </summary>
        /// <param name="size">Size of surface</param>
        /// <returns>new Surface</returns>
        public Surface CreateCompatibleSurface(Size size)
        {
            return this.CreateCompatibleSurface(size.Width, size.Height, false);
        }

        /// <summary>
        /// Create a surface with the same pixel format as this one
        /// </summary>
        /// <param name="size">The size of the surface.</param>
        /// <param name="hardware">Flag whether to hold the surface in video memory.</param>
        /// <returns></returns>
        public Surface CreateCompatibleSurface(Size size, bool hardware)
        {
            return this.CreateCompatibleSurface(size.Width, size.Height, hardware);
        }

        /// <summary>
        /// Create a surface with the same pixel format as this one
        /// </summary>
        /// <param name="width">width of surface</param>
        /// <param name="height">height of surface</param>
        /// <returns>new Surface</returns>
        public Surface CreateCompatibleSurface(
            int width, int height)
        {
            return this.CreateCompatibleSurface(width, height, false);
        }

        /// <summary>
        /// Create a surface with the same pixel format as this one
        /// </summary>
        /// <param name="width">The width of the new surface</param>
        /// <param name="height">The height of the new surface</param>
        /// <param name="hardware">
        /// Flag indicating whether to attempt to place the surface in 
        /// video memory
        /// </param>
        /// <returns>A new surface</returns>
        public Surface CreateCompatibleSurface(
            int width, int height, bool hardware)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }

            int flag = 0;
            if (hardware)
            {
                flag = (int)VideoModes.HardwareSurface;
            }
            Surface surface = new Surface(Sdl.SDL_CreateRGBSurface(
                flag,
                width,
                height,
                this.PixelFormat.Value.BitsPerPixel,
                this.PixelFormat.Value.Rmask,
                this.PixelFormat.Value.Gmask,
                this.PixelFormat.Value.Bmask,
                this.PixelFormat.Value.Amask));
            CloneFields(this, surface);
            return surface;
        }

        /// <summary>
        /// Converts the surface to the same pixel format as the source
        /// </summary>
        /// <param name="source">The source surface</param>
        /// <param name="hardware">
        /// A flag indicating whether or not to 
        /// attempt to place the new surface in video memory
        /// </param>
        /// <param name="alpha">Use alpha blending on surface</param>
        /// <returns>The new surface</returns>
        public Surface Convert(Surface source, bool hardware, bool alpha)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            int flags = 0;

            if (hardware)
            {
                flags = (int)VideoModes.HardwareSurface;
            }
            if (alpha)
            {
                flags |= (int)Alphas.RleEncoded;

            }

            return new Surface(Sdl.SDL_ConvertSurface(this.Handle, source.SurfaceStruct.format, flags));
        }

        /// <summary>
        /// Converts the surface to the same pixel format as the source
        /// </summary>
        /// <param name="source">The source surface</param>
        /// <returns>The new surface</returns>
        public Surface Convert(Surface source)
        {
            return this.Convert(source, false, false);
        }

        /// <summary>
        /// Converts this surface to the format of 
        /// the display window
        /// </summary>
        /// <returns>The new surface</returns>
        public Surface Convert()
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            return new Surface(Sdl.SDL_DisplayFormat(this.Handle));
        }

        /// <summary>
        /// Gets the size of the surface
        /// </summary>
        public System.Drawing.Size Size
        {
            get
            {
                return new System.Drawing.Size(this.SurfaceStruct.w, this.SurfaceStruct.h);
            }
        }

        /// <summary>
        /// Gets a rectangle that covers the entire of the surface
        /// </summary>
        public System.Drawing.Rectangle Rectangle
        {
            get
            {
                return new System.Drawing.Rectangle(0, 0, this.SurfaceStruct.w, this.SurfaceStruct.h);
            }
        }

        /// <summary>
        /// Gets the width of the surface
        /// </summary>
        public int Width
        {
            get
            {
                return (int)this.SurfaceStruct.w;
            }
        }

        /// <summary>
        /// Gets the height of the surface
        /// </summary>
        public int Height
        {
            get
            {
                return (int)this.SurfaceStruct.h;
            }
        }

        /// <summary>
        /// Copies another surface to this surface
        /// </summary>
        /// <param name="sourceSurface">
        /// The surface to copy from
        /// </param>
        /// <param name="destinationPosition">
        /// The rectangle coordinates on this surface to copy to
        /// </param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Correct Spelling")]
        public Rectangle Blit(Surface sourceSurface, System.Drawing.Point destinationPosition)
        {
            if (sourceSurface == null)
            {
                throw new ArgumentNullException("sourceSurface");
            }
            return this.Blit(
                sourceSurface,
                destinationPosition,
                new Rectangle(new System.Drawing.Point(0, 0), sourceSurface.Size));
        }

        /// <summary>
        /// Copies another surface to this surface
        /// </summary>
        /// <param name="sourceSurface">
        /// The surface to copy from
        /// </param>
        /// <param name="destinationRectangle">
        /// The rectangle coordinates on this surface to copy to
        /// </param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Correct Spelling")]
        public Rectangle Blit(Surface sourceSurface, System.Drawing.Rectangle destinationRectangle)
        {
            if (sourceSurface == null)
            {
                throw new ArgumentNullException("sourceSurface");
            }
            return this.Blit(
                sourceSurface,
                destinationRectangle.Location,
                new Rectangle(new System.Drawing.Point(0, 0), sourceSurface.Size));
        }

        /// <summary>
        /// Blits the given surface onto the current one.
        /// </summary>
        /// <param name="sourceSurface">The source surface to blit onto the current one.</param>
        /// <returns>A rectangle describing the location of the updated surface.</returns>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Correct Spelling")]
        public Rectangle Blit(Surface sourceSurface)
        {
            return this.Blit(
                sourceSurface,
                new Point(0, 0));
        }

        /// <summary>
        /// Blits a sprite onto the current surface.
        /// </summary>
        /// <param name="sprite">The sprite to blit.</param>
        /// <returns>A rectangle describing the location of the updated surface.</returns>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Correct Spelling")]
        public Rectangle Blit(Sprite sprite)
        {
            if (sprite == null)
            {
                throw new ArgumentNullException("sprite");
            }
            if (sprite.Visible)
            {
                //return this.Blit(sprite.Render(), sprite.Rectangle);
                return this.Blit(sprite.Surface, sprite.Rectangle);
            }
            else
            {
                return new Rectangle();
            }
        }

        /// <summary>
        /// Blits a sprite onto the current surface.
        /// </summary>
        /// <param name="sprite">The sprite to blit.</param>
        /// <param name="destinationPosition">The location where to blit the surface.</param>
        /// <returns>A rectangle describing the location of the updated surface.</returns>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Correct Spelling")]
        public Rectangle Blit(Sprite sprite, Point destinationPosition)
        {
            if (sprite == null)
            {
                throw new ArgumentNullException("sprite");
            }
            if (sprite.Visible)
            {
                //return this.Blit(sprite.Render(), destinationPosition);
                return this.Blit(sprite.Surface, destinationPosition);
            }
            else
            {
                return new Rectangle();
            }
        }

        /// <summary>
        /// Blits a sprite onto the current surface.
        /// </summary>
        /// <param name="sprite">The sprite to blit.</param>
        /// <param name="destinationRectangle">The location of the sprite on the destination.</param>
        /// <returns>A rectangle describing the location of the updated surface.</returns>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Correct Spelling")]
        public Rectangle Blit(Sprite sprite, Rectangle destinationRectangle)
        {
            if (sprite == null)
            {
                throw new ArgumentNullException("sprite");
            }
            if (sprite.Visible)
            {
                //return this.Blit(sprite.Render(), destinationRectangle);
                return this.Blit(sprite.Surface, destinationRectangle);
            }
            else
            {
                return new Rectangle();
            }
        }

        /// <summary>
        /// Blit entire SpriteCollection to Surface
        /// </summary>
        /// <param name="spriteCollection">SpriteCollection to Blit</param>
        /// <returns>Collection of Rectangles acutally blit to since 
        /// ere have may been some clipping.
        /// </returns>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Correct Spelling")]
        public Collection<Rectangle> Blit(SpriteCollection spriteCollection)
        {
            if (spriteCollection == null)
            {
                throw new ArgumentNullException("SpriteCollection");
            }
            return spriteCollection.Draw(this);
        }

        /// <summary>
        /// Blit surface to this surface
        /// </summary>
        /// <param name="sourceSurface">Source surface</param>
        /// <param name="destinationRectangle">
        /// Destination Reectangle on this surface
        /// </param>
        /// <param name="sourceRectangle">Source rectangel on source Surface</param>
        /// <returns>Actual blitted rectangle since there may have been clipping
        /// </returns>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Correct Spelling")]
        public Rectangle Blit(
            BaseSdlResource sourceSurface,
            System.Drawing.Rectangle destinationRectangle,
            System.Drawing.Rectangle sourceRectangle)
        {
            if (sourceSurface == null)
            {
                throw new ArgumentNullException("sourceSurface");
            }
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            Sdl.SDL_Rect s = Surface.ConvertRectToSdlRect(sourceRectangle);
            Sdl.SDL_Rect d = Surface.ConvertRectToSdlRect(destinationRectangle);
            int result = Sdl.SDL_BlitSurface(sourceSurface.Handle, ref s, this.Handle, ref d);
            GC.KeepAlive(this);
            if (result != (int)SdlFlag.Success)
            {
                throw SdlException.Generate();
            }
            return new Rectangle(d.x, d.y, d.w, d.h);
        }

        /// <summary>
        /// Copies a portion of a source surface to this surface
        /// </summary>
        /// <param name="sourceRectangle">
        /// The rectangle coordinates of the source surface to copy from
        /// </param>
        /// <param name="sourceSurface">The surface to copy from</param>
        /// <param name="destinationPosition">
        /// The coordinates on this surface to copy to
        /// </param>
        /// <returns>Destination Rectangle after any necessary clipping</returns>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Correct Spelling")]
        public Rectangle Blit(
            BaseSdlResource sourceSurface,
            System.Drawing.Point destinationPosition,
            System.Drawing.Rectangle sourceRectangle)
        {
            return this.Blit(sourceSurface,
                new Rectangle(
                destinationPosition.X,
                destinationPosition.Y, 0, 0),
                sourceRectangle);
        }

        /// <summary>
        /// Erases SpriteCollection from surface
        /// </summary>
        /// <param name="spriteCollection">SpriteCollection to erase</param>
        /// <param name="background">
        /// Background Surface to cover up SpriteCollection
        /// </param>
        public void Erase(SpriteCollection spriteCollection,
            Surface background)
        {
            if (spriteCollection == null)
            {
                throw new ArgumentNullException("spriteCollection");
            }
            spriteCollection.Erase(this, background);
        }

        /// <summary>
        /// Erase Rectangles from surface
        /// </summary>
        /// <param name="rectangle">Rectangle to erase</param>
        /// <param name="background">background to use to erase rectangle.</param>
        public void Erase(Rectangle rectangle, Surface background)
        {
            this.Blit(background, rectangle, rectangle);
        }

        /// <summary>
        /// Erase Rectangles from surface
        /// </summary>
        /// <param name="rectangles">Rectangle to erase</param>
        /// <param name="background">background to use to erase rectangle.</param>
        public void Erase(Collection<Rectangle> rectangles, BaseSdlResource background)
        {
            foreach (Rectangle rectangle in rectangles)
            {
                this.Blit(background, rectangle, rectangle);
            }
        }

        /// <summary>
        /// Locks a surface to allow direct pixel manipulation
        /// </summary>
        public void Lock()
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            if (MustLock)
            {
                int result = Sdl.SDL_LockSurface(this.Handle);
                GC.KeepAlive(this);
                if (result != (int)SdlFlag.Success)
                {
                    throw SdlException.Generate();
                }
            }
        }

        /// <summary>
        /// Gets a pointer to the raw pixel data of the surface
        /// </summary>
        public IntPtr Pixels
        {
            get
            {
                if (this.disposed)
                {
                    throw (new ObjectDisposedException(this.ToString()));
                }
                GC.KeepAlive(this);
                return this.SurfaceStruct.pixels;
            }
        }

        /// <summary>
        /// Unlocks a surface which has been locked.
        /// </summary>
        public void Unlock()
        {
            if (MustLock)
            {
                if (this.disposed)
                {
                    throw (new ObjectDisposedException(this.ToString()));
                }
                int result = Sdl.SDL_UnlockSurface(this.Handle);
                GC.KeepAlive(this);
                if (result != (int)SdlFlag.Success)
                {
                    throw SdlException.Generate();
                }
            }
        }

        /// <summary>
        /// Gets a flag indicating if it is neccessary to lock 
        /// the surface before accessing its pixel data directly
        /// </summary>
        public bool MustLock
        {
            get
            {
                if (this.disposed)
                {
                    throw (new ObjectDisposedException(this.ToString()));
                }

                int result = Sdl.SDL_MUSTLOCK(this.Handle);
                GC.KeepAlive(this);
                if (result == 1)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }

        /// <summary>
        /// Saves the surface to disk as a .bmp file
        /// </summary>
        /// <param name="file">The filename to save to</param>
        public void SaveBmp(string file)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            int result = Sdl.SDL_SaveBMP(this.Handle, file);
            GC.KeepAlive(this);
            if (result != (int)SdlFlag.Success)
            {
                throw SdlException.Generate();
            }
        }

        /// <summary>
        /// Get/set the transparent color of the image.
        /// </summary>
        public Color TransparentColor
        {
            get
            {
                return transparentColor;
            }
            set
            {
                transparentColor = value;
                if (this.transparent == true)
                {
                    this.Transparent = true;
                }
            }
        }

        /// <summary>
        /// Clears the transparent color for the surface
        /// </summary>
        public bool Transparent
        {
            get
            {
                return this.transparent;
            }
            set
            {
                this.transparent = value;
                if (value)
                {
                    if (this.disposed)
                    {
                        throw (new ObjectDisposedException(this.ToString()));
                    }
                    int flag = Sdl.SDL_SRCCOLORKEY | Sdl.SDL_RLEACCELOK;
                    int result = Sdl.SDL_SetColorKey(this.Handle, (int)flag, this.GetColorValue(this.transparentColor));
                    this.transparentInitialized = true;
                    GC.KeepAlive(this);
                    if (result != (int)SdlFlag.Success)
                    {
                        throw SdlException.Generate();
                    }
                }
                else
                {
                    if (this.disposed)
                    {
                        throw (new ObjectDisposedException(this.ToString()));
                    }
                    if (this.transparentInitialized)
                    {
                        int result = Sdl.SDL_SetColorKey(this.Handle, 0, 0);
                        GC.KeepAlive(this);
                        if (result != (int)SdlFlag.Success)
                        {
                            throw SdlException.Generate();
                        }
                    }
                }
            }
        }

        ///// <summary>
        ///// 
        ///// </summary>
        ///// <param name="dstPos"></param>
        ///// <param name="source"></param>
        ///// <param name="srcPos"></param>
        ///// <param name="sz"></param>
        //public void BlitAlpha(Point dstPos, Surface source, Point srcPos, Size sz)
        //{
        //    source.Alpha = 128;

        //    this.Blit(source, new Rectangle((short)dstPos.X,(short)dstPos.Y, (short)sz.Width,(short)sz.Height), new Rectangle( (short)srcPos.X, (short)srcPos.Y,(short)sz.Width,  (short)sz.Height));
        //    source.Alpha = 255;
        //}

        /// <summary>
        /// Source color key. A mask color that will not be copied to other Surfaces.
        /// </summary>
        public Color SourceColorKey
        {
            get { return Color.FromArgb(this.ColorKey); }
            set
            {
                this.ColorKey = Sdl.SDL_MapRGB(this.SurfaceStruct.format, value.R, value.G, value.B);
            }
        }

        private int colorKey;
        private int ColorKey
        {
            get { return colorKey; }
            set { colorKey = value; Tao.Sdl.Sdl.SDL_SetColorKey(this.Handle, Sdl.SDL_SRCCOLORKEY | Sdl.SDL_RLEACCEL, colorKey); }
        }

        //// retruns true if the color at the specified pixel is valid (opaque).
        ///// <summary>
        ///// 
        ///// </summary>
        ///// <param name="p"></param>
        ///// <returns></returns>
        //public bool HitTest(Point p) { return HitTest(p.X, p.Y); }

        //// retruns true if the color at the specified pixel is valid (opaque).
        ///// <summary>
        ///// 
        ///// </summary>
        ///// <param name="x"></param>
        ///// <param name="y"></param>
        ///// <returns></returns>
        //public bool HitTest(int x, int y)
        //{
        //    if (x < 0 || x > this.Size.Width || y < 0 || y > this.Size.Height)
        //        return false;
        //    return ((getColorAt(x, y) & 0xffffff) == colorKey);
        //}

        // returns color at specified point.
        // the return value suited for current pixel format.
        // outrange point will raise an error.
        //int getColorAt(int x, int y)
        //{
        //    Color c = this.GetPixel(new Point(x, y));
        //    return c.R & c.G & c.B;

        //}

        /// <summary>
        /// Sets/Gets the clipping rectangle for the surface
        /// </summary>
        public System.Drawing.Rectangle ClipRectangle
        {
            get
            {
                if (this.disposed)
                {
                    throw (new ObjectDisposedException(this.ToString()));
                }
                Sdl.SDL_Rect sdlrect =
                    Surface.ConvertRectToSdlRect(new System.Drawing.Rectangle());
                Sdl.SDL_GetClipRect(this.Handle, ref sdlrect);
                GC.KeepAlive(this);
                return new System.Drawing.Rectangle(sdlrect.x, sdlrect.y, sdlrect.w, sdlrect.h);
            }
            set
            {
                Sdl.SDL_Rect sdlrect = Surface.ConvertRectToSdlRect(value);
                Sdl.SDL_SetClipRect(this.Handle, ref sdlrect);
                GC.KeepAlive(this);
            }
        }

        /// <summary>
        /// Draws a pixel to this surface using the color value to speed things up - uses 1,2 or 4 BytesPerPixel modes.
        /// Call Lock() before calling this method.
        /// </summary>
        /// <param name="point">The coordinate of where to plot the pixel</param>
        /// <param name="color">The color value of the pixel</param>
        public void Draw(Point point, int color)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            Sdl.SDL_Surface surfaceStruct = this.SurfaceStruct;
            if (point.X < 0 || point.X >= surfaceStruct.w)
            {
                return;
            }
            if (point.Y < 0 || point.Y >= surfaceStruct.h)
            {
                return;
            }
            int bytesPerPixel = this.PixelFormat.Value.BytesPerPixel;
            IntPtr ptr = new IntPtr(surfaceStruct.pixels.ToInt32() + point.Y * surfaceStruct.pitch + point.X * bytesPerPixel);
            switch (bytesPerPixel)
            {
                case 1: // 8-bpp
                    Marshal.WriteByte(ptr, (Byte)color);
                    break;
                case 2: // 15-bpp or 16-bpp
                    Marshal.WriteInt16(ptr, (Int16)color);
                    break;
                case 3: // 24-bpp mode
                    MarshalHelper.WriteInt24(ptr, color);
                    break;
                case 4: // 32-bpp mode
                    Marshal.WriteInt32(ptr, color);
                    break;
                default:
                    throw new SdlException(Events.StringManager.GetString("UnknownBytesPerPixel", CultureInfo.CurrentUICulture));
            }
        }

        /// <summary>
        /// Draws a pixel to this surface - uses 1,2 or 4 BytesPerPixel modes.
        /// Call Lock() before calling this method.
        /// </summary>
        /// <remarks>
        /// copied from http://cone3d.gamedev.net/cgi-bin/index.pl?page=tutorials/gfxsdl/tut1
        /// </remarks>
        /// <param name="point">The coordinate of where to plot the pixel</param>
        /// <param name="color">The color of the pixel</param>
        public void Draw(Point point, System.Drawing.Color color)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            Draw(point, GetColorValue(color));
        }

        /// <summary>
        /// Draws a pixel on the surface using the provided alpha quantity.
        /// </summary>
        /// <param name="point">The coordinate of where to plot the pixel</param>
        /// <param name="color">The color of the pixel.  The alpha of this color is overwriten by the alpha value.</param>
        /// <param name="alpha">The alpha transparency to use for the color.</param>
        public void Draw(Point point, Color color, int alpha)
        {
            if (alpha <= 0)
            {
                return;
            }
            if (alpha >= 255)
            {
                Draw(point, color);
            }
            else
            {
                Draw(point, Color.FromArgb(alpha, color), true);
            }
        }

        /// <summary>
        /// Draws a pixel on the surface with the option of alpha transparency.
        /// </summary>
        /// <param name="point">The coordinate of where to plot the pixel</param>
        /// <param name="color">The color of the pixel. The alpha value of this color is used if the alpha flag is true.</param>
        /// <param name="alpha">A flag saying to use or not use alpha transparency (defaults to false).</param>
        /// <remarks>If alpha transparency is to be used, the color's alpha value is used.  This uses SDL_gfx's pixelRGBA method.</remarks>
        public void Draw(Point point, Color color, bool alpha)
        {
            if (alpha)
            {
                if (this.disposed)
                {
                    throw (new ObjectDisposedException(this.ToString()));
                }
                int result = SdlGfx.pixelRGBA(
                    this.Handle, (short)point.X, (short)point.Y,
                    color.R, color.G, color.B, color.A);
                GC.KeepAlive(this);
                if (result != (int)SdlFlag.Success)
                {
                    throw SdlException.Generate();
                }
            }
            else
            {
                Draw(point, color);
            }
        }

        /// <summary>
        /// Flips the rows of a surface, for use in an OpenGL texture for example
        /// </summary>
        public Surface CreateFlippedVerticalSurface()
        {
            //Surface surface = new Surface(SdlGfx.rotozoomSurfaceXY(
            //    this.Handle,
            //    0,
            //    1,
            //    -1,
            //    SdlGfx.SMOOTHING_OFF));
            //CloneFields(this, surface);
            //return surface;
            Surface surface = this.CreateScaledSurface(1);
            int first = 0;
            int second = surface.Height - 1;
            int pitch = surface.Pitch;
            byte[] tempByte = new byte[pitch];
            byte[] firstByte = new byte[pitch];


            surface.Lock();
            Int32 pixels = surface.SurfaceStruct.pixels.ToInt32();
            while (first < second)
            {
                IntPtr firstPtr = new IntPtr(pixels + first * pitch);
                IntPtr secondPtr = new IntPtr(pixels + second * pitch);

                //Take first scanline
                //Copy pointer data from scanline to tempByte array
                Marshal.Copy(firstPtr, tempByte, 0, pitch);
                //Take last scanline
                //Copy pointer data from scanline to firstByte array
                Marshal.Copy(secondPtr, firstByte, 0, pitch);
                //Take tempByte array
                //Copy pointer data from tempByte to last scanline
                Marshal.Copy(tempByte, 0, secondPtr, pitch);
                //Take firstByte array
                //Copy pointer data from firstByte array to first scanline
                Marshal.Copy(firstByte, 0, firstPtr, pitch);
                first++;
                second--;
            }
            surface.Unlock();

            return surface;
        }

        /// <summary>
        /// Flips the columns of a surface, for use in an OpenGL texture for example
        /// </summary>
        public Surface CreateFlippedHorizontalSurface()
        {
            using (Surface surface1 = this.CreateRotatedSurface(270))
            {
                using (Surface surface2 = surface1.CreateFlippedVerticalSurface())
                {
                    return surface2.CreateRotatedSurface(90);
                }
            }
        }

        /// <summary>
        /// Gets the pitch of the surface. Pitch is the number of bytes in a scanline of the surface.
        /// </summary>
        public short Pitch
        {
            get
            {
                return this.SurfaceStruct.pitch;
            }
        }

        /// <summary>
        /// Gets the color value of the pixel at the point.
        /// </summary>
        /// <param name="point">The coordinate of the surface</param>
        /// <returns>ColorValue of pixel</returns>
        public Color GetPixel(Point point)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            Sdl.SDL_Surface surfaceStruct = this.SurfaceStruct;
            if (point.X < 0 || point.X >= surfaceStruct.w)
            {
                throw new ArgumentOutOfRangeException("point", Events.StringManager.GetString("WidthOutOfRange", CultureInfo.CurrentUICulture));
            }
            if (point.Y < 0 || point.Y >= surfaceStruct.h)
            {
                throw new ArgumentOutOfRangeException("point", Events.StringManager.GetString("HeightOutOfRange", CultureInfo.CurrentUICulture));
            }
            int bytesPerPixel = this.PixelFormat.Value.BytesPerPixel;
            IntPtr ptr = new IntPtr(surfaceStruct.pixels.ToInt32() + point.Y * surfaceStruct.pitch + point.X * bytesPerPixel);
            int value;
            switch (bytesPerPixel)
            {
                case 1:
                    value = Marshal.ReadByte(ptr);
                    break;
                case 2:
                    value = Marshal.ReadInt16(ptr);
                    break;
                case 3:
                    value = MarshalHelper.ReadInt24(ptr);
                    break;
                case 4:
                    value = Marshal.ReadInt32(ptr);
                    break;
                default:
                    throw new SdlException(Events.StringManager.GetString("UnknownBytesPerPixel", CultureInfo.CurrentUICulture));
            }
            return this.GetColor(value);
        }




        /// <summary>
        /// Gets a 2D array of color values of the pixels in rectangle's area.
        /// </summary>
        /// <param name="rectangle">The rectangle of the pixels to get.</param>
        /// <returns>A 2D array of Colors describing the pixels in the rectangle.</returns>
        public Color[,] GetColors(Rectangle rectangle)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            if (rectangle.Width < 0)
            {
                throw new ArgumentOutOfRangeException("rectangle");
            }
            if (rectangle.Height < 0)
            {
                throw new ArgumentOutOfRangeException("rectangle");
            }
            Sdl.SDL_Surface surfaceStruct = this.SurfaceStruct;
            if (rectangle.X < 0 || rectangle.Right > surfaceStruct.w)
            {
                throw new ArgumentOutOfRangeException("rectangle");
            }
            if (rectangle.Y < 0 || rectangle.Top > surfaceStruct.h)
            {
                throw new ArgumentOutOfRangeException("rectangle");
            }
            Lock();
            try
            {
                int bytesPerPixel = this.PixelFormat.Value.BytesPerPixel;
                //the base address for the pixels.
                int pixels = surfaceStruct.pixels.ToInt32() + rectangle.X * bytesPerPixel;
                int pitch = surfaceStruct.pitch;
                Color[,] result = new Color[rectangle.Width, rectangle.Height];
                //These 3 ‘if’ blocks are a perfect candidate for generics unfortunately C# 
                //does not have the required constrains for this case. So I’m reduced to copying code.
                if (bytesPerPixel == 4)
                {
                    //the buffer for a row of pixels.
                    Int32[] buffer = new Int32[result.GetLength(0)];
                    for (int y = 0; y < result.GetLength(1); ++y)
                    {
                        //gets only the pixels in the row that are required.
                        Marshal.Copy(new IntPtr(pixels + (y + rectangle.Y) * pitch), buffer, 0, buffer.Length);
                        for (int x = 0; x < buffer.Length; ++x)
                        {
                            //converts the pixel to a color value.
                            result[x, y] = this.GetColor(buffer[x]);
                        }
                    }
                }
                else if (bytesPerPixel == 3)
                {
                    //the buffer for a row of pixels.
                    Int32[] buffer = new Int32[result.GetLength(0)];
                    for (int y = 0; y < result.GetLength(1); ++y)
                    {
                        //gets only the pixels in the row that are required.
                        MarshalHelper.CopyInt24(new IntPtr(pixels + (y + rectangle.Y) * pitch), buffer, 0, buffer.Length);
                        for (int x = 0; x < buffer.Length; ++x)
                        {
                            //converts the pixel to a color value.
                            result[x, y] = this.GetColor(buffer[x]);
                        }
                    }
                }
                else if (bytesPerPixel == 2)
                {
                    //the buffer for a row of pixels.
                    Int16[] buffer = new Int16[result.GetLength(0)];
                    for (int y = 0; y < result.GetLength(1); ++y)
                    {
                        //gets only the pixels in the row that are required.
                        Marshal.Copy(new IntPtr(pixels + (y + rectangle.Y) * pitch), buffer, 0, buffer.Length);
                        for (int x = 0; x < buffer.Length; ++x)
                        {
                            //converts the pixel to a color value.
                            result[x, y] = this.GetColor(buffer[x]);
                        }
                    }
                }
                else if (bytesPerPixel == 1)
                {
                    //the buffer for a row of pixels.
                    Byte[] buffer = new Byte[result.GetLength(0)];
                    for (int y = 0; y < result.GetLength(1); ++y)
                    {
                        //gets only the pixels in the row that are required.
                        Marshal.Copy(new IntPtr(pixels + (y + rectangle.Y) * pitch), buffer, 0, buffer.Length);
                        for (int x = 0; x < buffer.Length; ++x)
                        {
                            //converts the pixel to a color value.
                            result[x, y] = this.GetColor(buffer[x]);
                        }
                    }
                }
                else
                {
                    throw new SdlException(Events.StringManager.GetString("UnknownBytesPerPixel", CultureInfo.CurrentUICulture));
                }
                return result;
            }
            finally
            {
                Unlock();
            }
        }

        /// <summary>
        /// Sets a block of pixels.
        /// </summary>
        /// <param name="point">The top left corner of where the block should go.</param>
        /// <param name="colors">The 2D color array representing the pixels.</param>
        public void SetPixels(Point point, Color[,] colors)
        {
            if (colors == null)
            {
                throw new ArgumentNullException("colors");
            }
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            Sdl.SDL_Surface surfaceStruct = this.SurfaceStruct;
            if (point.X < 0 || point.X + colors.GetLength(0) > surfaceStruct.w)
            {
                throw new ArgumentOutOfRangeException("point");
            }
            if (point.Y < 0 || point.Y + colors.GetLength(1) > surfaceStruct.h)
            {
                throw new ArgumentOutOfRangeException("point");
            }
            Lock();
            try
            {
                int bytesPerPixel = this.PixelFormat.Value.BytesPerPixel;
                //the base address for the pixels.
                int pixels = surfaceStruct.pixels.ToInt32() + point.X * bytesPerPixel;
                int pitch = surfaceStruct.pitch;
                //These 3 ‘if’ blocks are a perfect candidate for generics unfortunately C# 
                //does not have the required constrains for this case. So I’m reduced to copying code.
                if (bytesPerPixel == 4)
                {
                    //the buffer for a row of pixels.
                    Int32[] buffer = new Int32[colors.GetLength(0)];
                    for (int y = 0; y < colors.GetLength(1); ++y)
                    {
                        //gets only the pixels in the row that are required.
                        for (int x = 0; x < buffer.Length; ++x)
                        {
                            //converts the pixel to a color value.
                            buffer[x] = GetColorValue(colors[x, y]);
                        }
                        //then copies them to the image.
                        Marshal.Copy(buffer, 0, new IntPtr(pixels + (y + point.Y) * pitch), buffer.Length);
                    }
                }
                else if (bytesPerPixel == 3)
                {
                    //the buffer for a row of pixels.
                    Int32[] buffer = new Int32[colors.GetLength(0)];
                    for (int y = 0; y < colors.GetLength(1); ++y)
                    {
                        //gets only the pixels in the row that are required.
                        for (int x = 0; x < buffer.Length; ++x)
                        {
                            //converts the pixel to a color value.
                            buffer[x] = GetColorValue(colors[x, y]);
                        }
                        //then copies them to the image.
                        MarshalHelper.CopyInt24(buffer, 0, new IntPtr(pixels + (y + point.Y) * pitch), buffer.Length);
                    }
                }
                else if (bytesPerPixel == 2)
                {
                    //the buffer for a row of pixels.
                    Int16[] buffer = new Int16[colors.GetLength(0)];
                    for (int y = 0; y < colors.GetLength(1); ++y)
                    {
                        //gets only the pixels in the row that are required.
                        for (int x = 0; x < buffer.Length; ++x)
                        {
                            //converts the pixel to a color value.
                            buffer[x] = (Int16)GetColorValue(colors[x, y]);
                        }
                        //then copies them to the image.
                        Marshal.Copy(buffer, 0, new IntPtr(pixels + (y + point.Y) * pitch), buffer.Length);
                    }
                }
                else if (bytesPerPixel == 1)
                {
                    //the buffer for a row of pixels.
                    Byte[] buffer = new Byte[colors.GetLength(0)];
                    for (int y = 0; y < colors.GetLength(1); ++y)
                    {
                        //gets only the pixels in the row that are required.
                        for (int x = 0; x < buffer.Length; ++x)
                        {
                            //converts the pixel to a color value.
                            buffer[x] = (Byte)GetColorValue(colors[x, y]);
                        }
                        //then copies them to the image.
                        Marshal.Copy(buffer, 0, new IntPtr(pixels + (y + point.Y) * pitch), buffer.Length);
                    }
                }
                else
                {
                    throw new SdlException(Events.StringManager.GetString("UnknownBytesPerPixel", CultureInfo.CurrentUICulture));
                }
            }
            finally
            {
                Unlock();
            }
        }

        /// <summary>
        /// AlphaBlending on Surface
        /// </summary>
        public bool AlphaBlending
        {
            get
            {
                return alphaBlending;
            }
            set
            {
                alphaBlending = value;
                if (value)
                {
                    this.Alpha = this.alpha;
                }
                else
                {
                    Alphas alphaFlags = Alphas.RleEncoded;
                    int result =
                        Sdl.SDL_SetAlpha(this.Handle, (int)(alphaFlags), this.alpha);
                    GC.KeepAlive(this);
                    if (result != (int)SdlFlag.Success)
                    {
                        throw SdlException.Generate();
                    }
                }
            }
        }

        /// <summary>
        /// Get/set the Alpha value of the image. 
        /// 0 indicates that the image fully transparent. 
        /// 255 indicates that the image is not transparent.
        /// </summary>
        public byte Alpha
        {
            get
            {
                return this.alpha;
            }
            set
            {
                Alphas alphaFlags = Alphas.RleEncoded;
                if (this.disposed)
                {
                    throw (new ObjectDisposedException(this.ToString()));
                }
                //TODO check this.
                if (alphaBlending)
                {
                    alphaFlags = alphaFlags | Alphas.SourceAlphaBlending;
                }
                int result =
                    Sdl.SDL_SetAlpha(this.Handle, (int)(alphaFlags), value);
                this.alpha = value;
                GC.KeepAlive(this);
                if (result != (int)SdlFlag.Success)
                {
                    throw SdlException.Generate();
                }
            }
        }

        ///// <summary>
        ///// Rotate surface.
        ///// </summary>
        ///// <remarks>Smoothing is turned on.</remarks>
        ///// <param name="degreesOfRotation">degrees of rotation</param>
        //public void Rotate(int degreesOfRotation)
        //{
        //    this.Rotate(degreesOfRotation, false);
        //}

        ///// <summary>
        ///// Rotate surface
        ///// </summary>
        ///// <param name="degreesOfRotation">degrees of rotation</param>
        ///// <param name="antiAlias">If true, smoothing will be turned on.</param>
        ///// <returns></returns>
        //public void Rotate(int degreesOfRotation, bool antiAlias)
        //{
        //    if (this.disposed)
        //    {
        //        throw (new ObjectDisposedException(this.ToString()));
        //    }
        //    int antiAliasParameter = SdlGfx.SMOOTHING_OFF;
        //    if (antiAlias == true)
        //    {
        //        antiAliasParameter = SdlGfx.SMOOTHING_ON;
        //    }

        //    IntPtr tempHandle = SdlGfx.rotozoomSurface(
        //        this.Handle,
        //        degreesOfRotation,
        //        1,
        //        antiAliasParameter);
        //    this.CloseHandle();
        //    this.Handle = tempHandle;
        //}

        /// <summary>
        /// Creates new Rotated Surface
        /// </summary>
        /// <param name="degreesOfRotation">Degrees to rotate Surface</param>
        /// <returns>new Surface</returns>
        public Surface CreateRotatedSurface(int degreesOfRotation)
        {
            return this.CreateRotatedSurface(degreesOfRotation, false);
        }

        /// <summary>
        /// Creates new Rotated Surface
        /// </summary>
        /// <param name="degreesOfRotation">Degrees to rotate Surface</param>
        /// <param name="antiAlias">Antialias</param>
        /// <returns>new Surface</returns>
        public Surface CreateRotatedSurface(int degreesOfRotation, bool antiAlias)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            int antiAliasParameter = SdlGfx.SMOOTHING_OFF;
            if (antiAlias == true)
            {
                antiAliasParameter = SdlGfx.SMOOTHING_ON;
            }

            Surface surface = new Surface(
                SdlGfx.rotozoomSurface(
                this.Handle,
                degreesOfRotation,
                1,
                antiAliasParameter));
            CloneFields(this, surface);
            return surface;
        }

        /// <summary>
        /// Create new rotated and zoomed surface
        /// </summary>
        /// <param name="degreesOfRotation">degrees of rotation</param>
        /// <param name="zoom">scale of zoom</param>
        /// <returns></returns>
        public Surface CreateRotatedZoomedSurface(int degreesOfRotation, double zoom)
        {
            return this.CreateRotatedZoomedSurface(degreesOfRotation, zoom, false);
        }

        /// <summary>
        /// Create new rotated and zoomed surface
        /// </summary>
        /// <param name="degreesOfRotation">degrees of rotation</param>
        /// <param name="zoom">scale of zoom</param>
        /// <param name="antiAlias">If true, moothing is turned on.</param>
        /// <returns></returns>
        public Surface CreateRotatedZoomedSurface(int degreesOfRotation,
            double zoom, bool antiAlias)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            int antiAliasParameter = SdlGfx.SMOOTHING_OFF;
            if (antiAlias == true)
            {
                antiAliasParameter = SdlGfx.SMOOTHING_ON;
            }

            Surface surface = new Surface(SdlGfx.rotozoomSurface(
                this.Handle,
                degreesOfRotation,
                zoom,
                antiAliasParameter));
            CloneFields(this, surface);
            return surface;
        }

        ///// <summary>
        ///// Rotate and Zoom surface
        ///// </summary>
        ///// <param name="degreesOfRotation">Degrees of rotation</param>
        ///// <param name="zoom">Scale of zoom</param>
        ///// <remarks>Smoothing is turned on.</remarks>
        //public void RotationZoom(int degreesOfRotation, double zoom)
        //{
        //    this.RotationZoom(degreesOfRotation, zoom, false);
        //}

        ///// <summary>
        ///// Rotate and zoom surface
        ///// </summary>
        ///// <param name="degreesOfRotation">degrees of rotation</param>
        ///// <param name="zoom">scale of zoom</param>
        ///// <param name="antiAlias">If true, moothing is turned on.</param>
        //public void RotationZoom(int degreesOfRotation,
        //    double zoom, bool antiAlias)
        //{
        //    if (this.disposed)
        //    {
        //        throw (new ObjectDisposedException(this.ToString()));
        //    }
        //    int antiAliasParameter = SdlGfx.SMOOTHING_OFF;
        //    if (antiAlias == true)
        //    {
        //        antiAliasParameter = SdlGfx.SMOOTHING_ON;
        //    }

        //    IntPtr tempHandle =
        //        SdlGfx.rotozoomSurface(
        //        this.Handle,
        //        degreesOfRotation,
        //        zoom,
        //        antiAliasParameter);

        //    this.CloseHandle();
        //    this.Handle = tempHandle;
        //}

        /// <summary>
        /// Create rescaled surface
        /// </summary>
        /// <param name="zoomX">Scale on X-axis</param>
        /// <param name="zoomY">Scale on Y-axis</param>
        /// <param name="antiAlias">If true, smoothing is turned on.</param>
        /// <returns>new Surface</returns>
        public Surface CreateScaledSurface(double zoomX, double zoomY, bool antiAlias)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            int antiAliasParameter = SdlGfx.SMOOTHING_OFF;
            if (antiAlias == true)
            {
                antiAliasParameter = SdlGfx.SMOOTHING_ON;
            }
            try
            {
                Surface surface = new Surface(SdlGfx.zoomSurface(this.Handle, zoomX, zoomY, antiAliasParameter));
                CloneFields(this, surface);
                return surface;
            }
            catch
            {
                throw;
            }
        }

        /// <summary>
        /// Create rescaled surface
        /// </summary>
        /// <param name="zoomX">Scale on X-axis</param>
        /// <param name="zoomY">Scale on Y-axis</param>
        /// <returns></returns>
        public Surface CreateScaledSurface(double zoomX, double zoomY)
        {
            return this.CreateScaledSurface(zoomX, zoomY, false);
        }

        /// <summary>
        /// Create rescaled surface
        /// </summary>
        /// <param name="zoom">Scale on both X and Y axes</param>
        /// <returns>new Surface</returns>
        public Surface CreateScaledSurface(double zoom)
        {
            return this.CreateScaledSurface(zoom, zoom);
        }

        /// <summary>
        /// Create rescaled surface
        /// </summary>
        /// <param name="zoom">Scale on both X and Y axes</param>
        /// <param name="antiAlias">antialias</param>
        /// <returns>new Surface</returns>
        public Surface CreateScaledSurface(double zoom, bool antiAlias)
        {
            return this.CreateScaledSurface(zoom, zoom, antiAlias);
        }

        ///// <summary>
        ///// Rescale surface
        ///// </summary>
        ///// <param name="zoomX">Scale on X-axis</param>
        ///// <param name="zoomY">Scale on Y-axis</param>
        //public void Scale(double zoomX, double zoomY)
        //{
        //    if (this.disposed)
        //    {
        //        throw (new ObjectDisposedException(this.ToString()));
        //    }
        //    this.Scale(zoomX, zoomY, false);
        //}

        ///// <summary>
        ///// Rescale surface
        ///// </summary>
        ///// <param name="zoomX">Scale on X-axis</param>
        ///// <param name="zoomY">Scale on Y-axis</param>
        ///// <param name="antiAlias">If true, smoothing is turned on.</param>
        //public void Scale(double zoomX, double zoomY, bool antiAlias)
        //{
        //    if (this.disposed)
        //    {
        //        throw (new ObjectDisposedException(this.ToString()));
        //    }
        //    int antiAliasParameter = SdlGfx.SMOOTHING_OFF;
        //    if (antiAlias == true)
        //    {
        //        antiAliasParameter = SdlGfx.SMOOTHING_ON;
        //    }
        //    try
        //    {
        //        IntPtr tempHandle =
        //            SdlGfx.zoomSurface(this.Handle, zoomX, zoomY, antiAliasParameter);
        //        this.CloseHandle();
        //        this.Handle = tempHandle;
        //    }
        //    catch
        //    {
        //        throw;
        //    }
        //}

        ///// <summary>
        ///// Scale surface on both axes
        ///// </summary>
        ///// <param name="zoom">Scale amount</param>
        //public void Scale(double zoom)
        //{
        //    if (this.disposed)
        //    {
        //        throw (new ObjectDisposedException(this.ToString()));
        //    }
        //    this.Scale(zoom, zoom);
        //}

        ///// <summary>
        ///// Scale surface on both axes
        ///// </summary>
        ///// <param name="zoom">Scale amount</param>
        ///// <param name="antiAlias">If true, smoothing is turned on</param>
        //public void Scale(double zoom, bool antiAlias)
        //{
        //    if (this.disposed)
        //    {
        //        throw (new ObjectDisposedException(this.ToString()));
        //    }
        //    this.Scale(zoom, zoom, antiAlias);
        //}

        /// <summary>
        /// Doubles the size of the surface
        /// </summary>
        /// <returns>new Surface</returns>
        public Surface CreateScaleDoubleSurface()
        {
            return this.CreateScaledSurface(2);
        }

        /// <summary>
        /// Doubles the size of the surface
        /// </summary>
        /// <returns>new Surface</returns>
        public Surface CreateScaleDoubleSurface(bool antiAlias)
        {
            return this.CreateScaledSurface(2, antiAlias);
        }

        ///// <summary>
        ///// Doubles the size of the surface
        ///// </summary>
        //public void ScaleDouble()
        //{
        //    if (this.disposed)
        //    {
        //        throw (new ObjectDisposedException(this.ToString()));
        //    }
        //    this.Scale(2, 2);
        //}

        ///// <summary>
        ///// Doubles the size of the surface
        ///// </summary>
        ///// <param name="antiAlias">If true</param>
        ///// <returns></returns>
        //public void ScaleDouble(bool antiAlias)
        //{
        //    if (this.disposed)
        //    {
        //        throw (new ObjectDisposedException(this.ToString()));
        //    }
        //    this.Scale(2, 2, antiAlias);
        //}

        ///// <summary>
        ///// Stretch Surface
        ///// </summary>
        ///// <param name="sourceRectangle">Source Rectangle</param>
        ///// <param name="destinationRectangle">Destination of stretch</param>
        ///// <returns>new Surface</returns>
        //public void Stretch(Rectangle sourceRectangle, Rectangle destinationRectangle)
        //{
        //    Surface surface = new Surface(sourceRectangle);
        //    //Surface surface = (Surface)this.Clone();
        //    Color colorTemp = this.TransparentColor;
        //    this.Transparent = false;
        //    surface.Blit(this, new Point(0, 0), sourceRectangle);
        //    this.transparentColor = colorTemp;
        //    double stretchWidth = ((double)destinationRectangle.Width / (double)sourceRectangle.Width);
        //    double stretchHeight = ((double)destinationRectangle.Height / (double)sourceRectangle.Height);
        //    surface.Scale(stretchWidth, stretchHeight);
        //    CloneFields(this, surface);
        //    this.Handle = surface.Handle;
        //}

        ///// <summary>
        ///// Stretch Surface
        ///// </summary>
        ///// <param name="destinationSize">Destination of stretch</param>
        ///// <returns>new Surface</returns>
        //public void Stretch(Size destinationSize)
        //{
        //    double stretchWidth = ((double)destinationSize.Width / (double)this.Width);
        //    double stretchHeight = ((double)destinationSize.Height / (double)this.Height);
        //    this.Scale(stretchWidth, stretchHeight);
        //}

        /// <summary>
        /// Stretch Surface
        /// </summary>
        /// <param name="sourceRectangle">Source Rectangle</param>
        /// <param name="destinationRectangle">Destination of stretch</param>
        /// <returns>new Surface</returns>
        public Surface CreateStretchedSurface(Rectangle sourceRectangle, Rectangle destinationRectangle)
        {
            using (Surface surface1 = new Surface(sourceRectangle))
            {
                //Surface surface = (Surface)this.Clone();
                Color colorTemp = this.TransparentColor;
                this.Transparent = false;
                surface1.Blit(this, new Point(0, 0), sourceRectangle);
                this.transparentColor = colorTemp;
                double stretchWidth = ((double)destinationRectangle.Width / (double)sourceRectangle.Width);
                double stretchHeight = ((double)destinationRectangle.Height / (double)sourceRectangle.Height);
                Surface surface2 = surface1.CreateScaledSurface(stretchWidth, stretchHeight);
                CloneFields(this, surface2);
                return surface2;
            }
        }

        /// <summary>
        /// Stretch Surface
        /// </summary>
        /// <param name="destinationSize">Destination of stretch</param>
        /// <returns>new Surface</returns>
        public Surface CreateStretchedSurface(Size destinationSize)
        {
            using (Surface surface1 = (Surface)this.Clone())
            {
                double stretchWidth = ((double)destinationSize.Width / (double)this.Width);
                double stretchHeight = ((double)destinationSize.Height / (double)this.Height);
                return surface1.CreateScaledSurface(stretchWidth, stretchHeight);
            }
        }

        /// <summary>
        /// Reads data from a stream until the end is reached. The
        /// data is returned as a byte array. An IOException is
        /// thrown if any of the underlying IO calls fail.
        /// </summary>
        /// <remarks>From http://www.yoda.arachsys.com/csharp
        /// skeet@pobox.com</remarks>
        /// <param name="stream">The stream to read data from</param>
        /// <param name="initialLength">The initial buffer length</param>
        private static byte[] ReadFully(Stream stream, long initialLength)
        {
            // If we've been passed an unhelpful initial length, just
            // use 32K.
            if (initialLength < 1)
            {
                initialLength = 32768;
            }

            byte[] buffer = new byte[initialLength];
            int read = 0;

            int chunk;
            while ((chunk = stream.Read(buffer, read, buffer.Length - read)) > 0)
            {
                read += chunk;

                // If we've reached the end of our buffer, check to see if there's
                // any more information
                if (read == buffer.Length)
                {
                    int nextByte = stream.ReadByte();

                    // End of stream? If so, we're done
                    if (nextByte == -1)
                    {
                        return buffer;
                    }

                    // Nope. Resize the buffer, put in the byte we've just
                    // read, and continue
                    byte[] newBuffer = new byte[buffer.Length * 2];
                    Array.Copy(buffer, newBuffer, buffer.Length);
                    newBuffer[read] = (byte)nextByte;
                    buffer = newBuffer;
                    read++;
                }
            }
            // Buffer is now too big. Shrink it.
            byte[] ret = new byte[read];
            Array.Copy(buffer, ret, read);
            return ret;
        }

        ///// <summary>
        ///// Resize Surface
        ///// </summary>
        ///// <param name="destinationSize">Size of new Surface</param>
        ///// <returns>new Surface</returns>
        //public void Resize(Size destinationSize)
        //{
        //    Surface surface = CreateResizedSurfaceInternal(destinationSize);     
        //    this.Handle = CreateResizedSurfaceInternal(destinationSize).Handle;     
        //}

        ///// <summary>
        ///// Resize surface to next power of two size. Useful for OpenGL.
        ///// </summary>
        //public void Resize()
        //{
        //    this.Resize(new Size(NextPowerOfTwo(this.Width), NextPowerOfTwo(this.Height)));
        //}

        private Surface CreateResizedSurfaceInternal(Size destinationSize)
        {
            Surface surface = resizeSurface.CreateStretchedSurface(destinationSize);
            surface.Blit(this);
            return surface;
        }

        /// <summary>
        /// Resize surface to next power of two size. Useful for OpenGL.
        /// </summary>
        public Surface CreateResizedSurface()
        {
            return this.CreateResizedSurface(new Size(NextPowerOfTwo(this.Width), NextPowerOfTwo(this.Height)));
        }

        /// <summary>
        /// Resize Surface
        /// </summary>
        /// <param name="destinationSize">Size of new Surface</param>
        /// <returns>new Surface</returns>
        public Surface CreateResizedSurface(Size destinationSize)
        {
            Surface surface = CreateResizedSurfaceInternal(destinationSize);
            CloneFields(this, surface);
            return surface;
        }

        private static int NextPowerOfTwo(int x)
        {
            double logbase2 = (Math.Log(x) / Math.Log(2));
            return (int)Math.Round(Math.Pow(2, Math.Ceiling(logbase2)));
        }

        /// <summary>
        /// Uses a Transformation object to perform rotation, zooming/scaling
        /// </summary>
        /// <param name="transformation">Transformation object</param>
        public Surface CreateTransformedSurface(Transformation transformation)
        {
            //this method and has duplicate logic with CreateRotatedZoomedSurface.
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            if (transformation == null)
            {
                throw new ArgumentNullException("transformation");
            }
            int antiAliasParameter = (transformation.AntiAlias) ? (SdlGfx.SMOOTHING_ON) : (SdlGfx.SMOOTHING_OFF);
            Surface surface =
                new Surface(
                    SdlGfx.rotozoomSurfaceXY(
                        this.Handle,
                        transformation.DegreesOfRotation,
                        transformation.ScaleX,
                        transformation.ScaleY,
                        antiAliasParameter));
            CloneFields(this, surface);
            return surface;
        }

        /// <summary>
        /// Updates rectangle
        /// </summary>
        /// <param name="rectangle">Rectangle to update</param>
        public void Update(System.Drawing.Rectangle rectangle)
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            Sdl.SDL_UpdateRect(
                this.Handle,
                rectangle.X,
                rectangle.Y,
                rectangle.Width,
                rectangle.Height);
            GC.KeepAlive(this);
        }

        /// <summary>
        /// Updates entire surface. If the surface is double-buffered, 
        /// this method will flip the back buffer onto the screen
        /// </summary>
        public void Update()
        {
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            Sdl.SDL_Flip(this.Handle);
            GC.KeepAlive(this);
        }

        /// <summary>
        /// Update an array of rectangles
        /// </summary>
        /// <param name="rectangles">Array of Rectangles to update</param>
        public void Update(System.Drawing.Rectangle[] rectangles)
        {
            if (rectangles == null)
            {
                throw new ArgumentNullException("rectangles");
            }
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            Sdl.SDL_Rect[] rects = new Sdl.SDL_Rect[rectangles.Length];
            for (int i = 0; i < rectangles.Length; i++)
            {
                rects[i] = Surface.ConvertRectToSdlRect(rectangles[i]);
            }
            Sdl.SDL_UpdateRects(this.Handle, rects.Length, rects);
            GC.KeepAlive(this);
        }

        /// <summary>
        /// Update an array of rectangles
        /// </summary>
        /// <param name="rectangles">Collection of rectangles to update</param>
        public void Update(Collection<Rectangle> rectangles)
        {
            if (rectangles == null)
            {
                throw new ArgumentNullException("rectangles");
            }
            if (this.disposed)
            {
                throw (new ObjectDisposedException(this.ToString()));
            }
            Sdl.SDL_Rect[] rects = new Sdl.SDL_Rect[rectangles.Count];
            for (int i = 0; i < rectangles.Count; i++)
            {
                rects[i] = Surface.ConvertRectToSdlRect(rectangles[i]);
            }
            Sdl.SDL_UpdateRects(this.Handle, rects.Length, rects);
            GC.KeepAlive(this);
        }

        /// <summary>
        /// Gets the number of Bits per pixel.
        /// </summary>
        /// <remarks>Typically 8, 16, 24 or 32</remarks>
        public byte BitsPerPixel
        {
            get
            {
                return this.PixelFormat.Value.BitsPerPixel;
            }
        }

        /// <summary>
        /// Gets the number of bytes per pixel for this surface
        /// </summary>
        /// <remarks>Tyically 1, 2, 3 or 4</remarks>
        public byte BytesPerPixel
        {
            get
            {
                return this.PixelFormat.Value.BytesPerPixel;
            }
        }

        /// <summary>
        /// AlphaMask
        /// </summary>
        public int AlphaMask
        {
            get
            {
                return this.PixelFormat.Value.Amask;
            }
        }

        /// <summary>
        /// Mask for Red channel
        /// </summary>
        public int RedMask
        {
            get
            {
                return this.PixelFormat.Value.Rmask;
            }
        }

        /// <summary>
        /// Mask for Green channel
        /// </summary>
        public int GreenMask
        {
            get
            {
                return this.PixelFormat.Value.Gmask;
            }
        }

        /// <summary>
        /// Mask for Blue channel
        /// </summary>
        public int BlueMask
        {
            get
            {
                return this.PixelFormat.Value.Bmask;
            }
        }

        /// <summary>
        /// Left Shift for blue channel
        /// </summary>
        public int BlueShift
        {
            get
            {
                return this.PixelFormat.Value.Bshift;
            }
        }

        /// <summary>
        /// Left shift for red channel
        /// </summary>
        public int RedShift
        {
            get
            {
                return this.PixelFormat.Value.Rshift;
            }
        }

        /// <summary>
        /// Left shift for green channel
        /// </summary>
        public int GreenShift
        {
            get
            {
                return this.PixelFormat.Value.Gshift;
            }
        }

        /// <summary>
        /// Left shift for Alpha channel
        /// </summary>
        public int AlphaShift
        {
            get
            {
                return this.PixelFormat.Value.Ashift;
            }
        }

        /// <summary>
        /// Gets the percision loss for the alpha component.
        /// </summary>
        public int AlphaLoss
        {
            get
            {
                return this.PixelFormat.Value.Aloss;
            }
        }

        /// <summary>
        /// Gets the percision loss for the red component.
        /// </summary>
        public int RedLoss
        {
            get
            {
                return this.PixelFormat.Value.Rloss;
            }
        }

        /// <summary>
        /// Gets the percision loss for the green component.
        /// </summary>
        public int GreenLoss
        {
            get
            {
                return this.PixelFormat.Value.Gloss;
            }
        }

        /// <summary>
        /// Gets the percision loss for the blue component.
        /// </summary>
        public int BlueLoss
        {
            get
            {
                return this.PixelFormat.Value.Bloss;
            }
        }

        /// <summary>
        /// Surface flags
        /// </summary>
        public int Flags
        {
            get
            {
                return this.SurfaceStruct.flags;
            }
        }

        /// <summary>
        /// Surface is fullscreen
        /// </summary>
        public bool FullScreen
        {
            get
            {
                return ((this.SurfaceStruct.flags & (int)VideoModes.FullScreen) == (int)VideoModes.FullScreen);
            }
        }

        /// <summary> 
        /// Makes a new surface which 
        /// contains a portion of the current surface. 
        /// </summary> 
        /// <param name="clip">
        /// The rectangle on the current surface to be clipped.
        /// </param> 
        /// <returns>A clip of the new surface.</returns> 
        public Surface CreateSurfaceFromClipRectangle(Rectangle clip)
        {
            Surface final =
                this.CreateCompatibleSurface(clip.Width, clip.Height);
            final.Blit(this, new Point(0, 0), clip);
            return final;
        }

        #endregion Public Methods

        #region ICloneable Members

        /// <summary>
        /// Creates a shallow copy of the Surface.
        /// </summary>
        /// <returns>
        /// Returns an object that needs to be cast to a Surface
        /// </returns>
        public object Clone()
        {
            return Clone(false);
        }

        /// <summary>
        /// Creates a copy of the Surface
        /// </summary>
        /// <param name="doDeepCopy">If true, a deep copy is created</param>
        /// <returns>clooned object</returns>
        public object Clone(bool doDeepCopy)
        {
            if (doDeepCopy)
            {
                Surface surf = new Surface(SdlGfx.zoomSurface(this.Handle, 1, 1, SdlGfx.SMOOTHING_OFF));
                CloneFields(this, surf);
                return (surf);
            }
            else
            {
                Surface surf = new Surface(SdlGfx.zoomSurface(this.Handle, 1, 1, SdlGfx.SMOOTHING_OFF));
                CloneFields(this, surf);
                return (surf);
            }
        }

        #endregion
    }

    /// <summary>
    /// A class to help with the manipulation of 24 bit ints.
    /// TODO: test to see if BigEndian will break it.
    /// </summary>
    static class MarshalHelper
    {
        private const int sizeofInt24 = 3;
        private static readonly int offset = ((BitConverter.IsLittleEndian) ? (0) : (1));

        public static Int32 ReadInt24(IntPtr ptr)
        {
            //creates a buffer to put the data read for the pointer
            Byte[] buffer = new Byte[sizeofInt24];
            //then reads it from the pointer.
            Marshal.Copy(ptr, buffer, 0, sizeofInt24);

            //creates the actaul return value
            Int32[] result = new Int32[1] { 0 };
            //then copies the data in the buffer into it.
            Buffer.BlockCopy(buffer, 0, result, offset, sizeofInt24);
            return result[0];
        }
        public static void WriteInt24(IntPtr ptr, Int32 value)
        {
            Int32[] valueArray = new Int32[1] { value };
            Byte[] buffer = new Byte[sizeofInt24];
            Buffer.BlockCopy(valueArray, offset, buffer, 0, sizeofInt24);
            Marshal.Copy(buffer, 0, ptr, sizeofInt24);
        }
        public static void CopyInt24(Int32[] array, int startIndex, IntPtr destination, int length)
        {
            if (array == null) { throw new ArgumentNullException("array"); }
            if (startIndex < 0 || length + startIndex > array.Length) { throw new ArgumentOutOfRangeException("startIndex"); }
            Byte[] buffer = new byte[length * sizeofInt24];
            for (int index = startIndex * sizeof(Int32), index2 = 0;
                index2 < buffer.Length;
                index2 += sizeofInt24, index += sizeof(Int32))
            {
                Buffer.BlockCopy(array, index + offset, buffer, index2, sizeofInt24);
            }
            Marshal.Copy(buffer, 0, destination, buffer.Length);
        }
        public static void CopyInt24(IntPtr source, Int32[] array, int startIndex, int length)
        {
            if (array == null) { throw new ArgumentNullException("array"); }
            if (startIndex < 0 || length + startIndex > array.Length) { throw new ArgumentOutOfRangeException("startIndex"); }
            Byte[] buffer = new byte[length * sizeofInt24];
            Marshal.Copy(source, buffer, 0, buffer.Length);
            Array.Clear(array, startIndex, length);
            for (int index = startIndex * sizeof(Int32), index2 = 0;
                index2 < buffer.Length;
                index2 += sizeofInt24, index += sizeof(Int32))
            {
                Buffer.BlockCopy(buffer, index2, array, index + offset, sizeofInt24);
            }
        }
    }
}
